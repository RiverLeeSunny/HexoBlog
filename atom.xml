<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>River</title>
  <subtitle>以梦为马，不负韶光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LiJiang.com/"/>
  <updated>2017-09-11T03:56:47.000Z</updated>
  <id>http://LiJiang.com/</id>
  
  <author>
    <name>River</name>
    <email>lijiangsiyu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The version of CocoaPods used to generate the lockfile (1.0.1) is higher than the version of the current executable (1.0.0)</title>
    <link href="http://LiJiang.com/2017/09/09/The-version-of-CocoaPods-used-to-generate-the-lockfile-1-0-1-is-higher-than-the-version-of-the-current-executable-1-0-0/"/>
    <id>http://LiJiang.com/2017/09/09/The-version-of-CocoaPods-used-to-generate-the-lockfile-1-0-1-is-higher-than-the-version-of-the-current-executable-1-0-0/</id>
    <published>2017-09-09T03:25:36.000Z</published>
    <updated>2017-09-11T03:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>执行pod install时出现如下信息：  </p>
<div><br>    <div align="center"><br>    <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-09-0911.27.51.png?raw=true" width="700" height="30" alt="图片名称" align="center"><br></div>  


<a id="more"></a>  
<p>问题的原因是：CocoaPods的版本太低  </p>
<p>解决问题：  </p>
<ul>
<li><p>检查gem ruby版本（建议 2.6.x 以上）<br>gem -v</p>
</li>
<li><p>升级gem版本<br>如果你现在使用的源是<a href="https://rubygems.org/请换成https://gems.ruby-china.org/" target="_blank" rel="external">https://rubygems.org/请换成https://gems.ruby-china.org/</a></p>
<p> 移除现有Ruby默认源<br> gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br> 使用新的源<br> gem sources -a  <a href="https://gems.ruby-china.org/" target="_blank" rel="external">https://gems.ruby-china.org/</a><br> 验证新源是否替换成功<br> gem sources -l  </p>
</li>
<li><p>安装CocoaPods<br>(1) sudo gem install -n /usr/local/bin cocoapods<br>输入电脑密码, 回车等待.<br>(2) pod setup  </p>
</li>
</ul>
<p>版本更新：sudo gem install cocoapods –pre</p>
<p>安装或更新完毕检查版本：pod –version再次执行pod install就可以了</p>
</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行pod install时出现如下信息：  &lt;/p&gt;
&lt;div&gt;&lt;br&gt;    &lt;div align=&quot;center&quot;&gt;&lt;br&gt;    &lt;img src=&quot;https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-09-0911.27.51.png?raw=true&quot; width=&quot;700&quot; height=&quot;30&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://LiJiang.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://LiJiang.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS第三方库汇总</title>
    <link href="http://LiJiang.com/2017/08/30/%E8%BD%AC-iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%B1%87%E6%80%BB/"/>
    <id>http://LiJiang.com/2017/08/30/转-iOS第三方库汇总/</id>
    <published>2017-08-30T03:58:39.000Z</published>
    <updated>2017-08-30T04:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/91232c11770e" target="_blank" rel="external">原文</a>  </p>
<ul>
<li>开源项目</li>
</ul>
<p><a href="https://github.com/imlifengfeng/iOSBlogAndTools" target="_blank" rel="external">iOSBlogAndTools</a>iOS开发优秀博客和软件推荐<br><a href="https://github.com/CodeHubApp/CodeHub" target="_blank" rel="external">CodeHub</a>browse and maintain your GitHub repositories on any iOS device!<br><a href="https://github.com/dkhamsing/open-source-ios-apps" target="_blank" rel="external">Open-Source iOS Apps</a>开源iOS apps列表  </p>
<a id="more"></a>
<ul>
<li>弹框</li>
</ul>
<p><a href="https://github.com/imlifengfeng/FFToast" target="_blank" rel="external">FFToastGitHub</a>中最强大的iOS Notification和AlertView框架，没有之一！<br><a href="https://github.com/12207480/TYAlertController" target="_blank" rel="external">TYAlertController</a>各种风格的弹框，满足你的各种需求<br><a href="https://github.com/UncleJoke/JKPopMenuView" target="_blank" rel="external">JKPopMenuView</a>简单的弹出菜单<br><a href="https://github.com/adad184/MMPopupView" target="_blank" rel="external">MMPopupView</a>精简的弹框，非常漂亮，和喜欢<br><a href="https://github.com/martinjuhasz/MJPopupViewController" target="_blank" rel="external">MJPopupViewController</a>A UIViewController Category to display a ViewController as a popup with different transition effects.<br><a href="https://github.com/questbeat/QBPopupMenu" target="_blank" rel="external">QBPopupMenu</a>自定义popup menu，外观和iOS7上的UIMenuController类似<br><a href="https://github.com/cezarywojcik/CWStatusBarNotification" target="_blank" rel="external">CWStatusBarNotification</a>状态栏通知<br><a href="https://github.com/12207480/DOPDropDownMenu-Enhanced" target="_blank" rel="external">DOPDropDownMenu</a>下拉列表菜单<br><a href="https://github.com/jmascia/KLCPopup" target="_blank" rel="external">KLCPopup</a>非常漂亮的弹出控件  </p>
<ul>
<li>自动布局</li>
</ul>
<p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>最优雅的自动布局解决方案，支持链式编程<br><a href="https://github.com/PureLayout/PureLayout" target="_blank" rel="external">PureLayout</a>又一强大的自动布局解决方案<br><a href="https://github.com/gsdios/SDAutoLayout" target="_blank" rel="external">SDAutoLayout</a>一行代码搞定自动布局  </p>
<ul>
<li>网络请求</li>
</ul>
<p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>地球人都在用<br><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">CocoaAsyncSocket</a>封装最完善的Socket类库<br><a href="https://github.com/RxSwiftCommunity/RxAlamofire" target="_blank" rel="external">RxAlamofire</a>封装Alamofire  </p>
<ul>
<li>基础工具类以及Category</li>
</ul>
<p><a href="https://github.com/soffes/sstoolkit" target="_blank" rel="external">sstoolkit</a>一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西<br><a href="https://github.com/FabrizioBrancati/BFKit-Swift" target="_blank" rel="external">BFKitSwift版本</a> 国外的一个大神写的很好用的分类，比较齐全<br><a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a>ibireme用心之作<br><a href="https://zwaldowski.github.io/BlocksKit" target="_blank" rel="external">BlocksKit</a>为基础类提供Block支持，很好用<br><a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="external">DateTools</a>非常强大的日期处理工具<br><a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="external">FlatUIKit</a>扩展Foundation基本UI主件，扁平化风格<br><a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="external">iOS-Categories</a>iOS Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.<br><a href="https://github.com/kimziv/PinYin4Objc" target="_blank" rel="external">PinYin4Objc</a>拼音解析<br><a href="https://github.com/mattconnolly/ZipArchive" target="_blank" rel="external">ZipArchive</a>解压缩<br><a href="https://github.com/ViccAlexander/Chameleon" target="_blank" rel="external">Chameleon</a>扁平颜色框架，可以创建非常漂亮的颜色<br><a href="https://github.com/ChenYilong/CYLTabBarController" target="_blank" rel="external">CYLTabBarController</a>低耦合集成TabBarController<br><a href="https://github.com/cwRichardKim/RKNotificationHub" target="_blank" rel="external">RKNotificationHub</a>在右上方显示通知小角标<br><a href="https://github.com/fpt-software/Material-Controls-For-iOS" target="_blank" rel="external">Material-Controls-For-iOS</a>Google风格的控件<br><a href="https://github.com/wangruofeng/YYKit" target="_blank" rel="external">YYKit</a>A collection of iOS components.</p>
<p>动画</p>
<p><a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="external">JHChainableAnimations</a>链式动画编程，有点Masonry的味道<br><a href="http://canvaspod.io" target="_blank" rel="external">Canvas</a>非常强大的动画框架<br><a href="https://github.com/ColinEberhardt/VCTransitionsLibrary" target="_blank" rel="external">VCTransitionsLibrary</a>转场动画库<br><a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a>各种3D变换的动画，以前用过，炫酷得没朋友<br><a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="external">tapkulibrary</a>Tapku remain home to the things like the calendar UIs, coverflow, and any legacy classes, ect.<br><a href="https://github.com/AlexeyBelezeko/TBIconTransitionKit" target="_blank" rel="external">TBIconTransitionKit</a>点击按钮过渡动画 + –&gt; x - –&gt; +<br><a href="https://github.com/MengTo/Spring" target="_blank" rel="external">Spring</a>A library to simplify iOS animations in Swift<br><a href="https://github.com/ameizi/awesome-ios-animation" target="_blank" rel="external">awesome-iOS-animation</a>iOS动画库整理收集<br><a href="https://github.com/NghiaTranUIT/FeSpinner" target="_blank" rel="external">FeSpinner</a>Rocket Loader Collection for iOS app,有一些非常有趣的loading动画<br><a href="https://github.com/seedante/SDECollectionViewAlbumTransition" target="_blank" rel="external">SDECollectionViewAlbumTransition</a>CollectionView相册自定义转场<br><a href="https://github.com/Raizlabs/RZTransitions" target="_blank" rel="external">RZTransitions</a>A library of custom iOS View Controller Animations and Interactions.<br><a href="https://github.com/shu223/AnimatedTransitionGallery" target="_blank" rel="external">AnimatedTransition</a>Gallery各种自定义转场动画收集，非常值得学习<br><a href="https://github.com/Yalantis/StarWars.iOS" target="_blank" rel="external">StarWars.iOS</a>非常炫酷的CAShapeLayer动画，非常炫酷<br><a href="https://github.com/YouXianMing/Animations" target="_blank" rel="external">Animations</a>来自极客学院的YouXianMing的一些动画收集<br><a href="https://github.com/zoonooz/ZFDragableModalTransition" target="_blank" rel="external">ZFDragableModalTransition</a>Custom animation transition for present modal view controller  </p>
<ul>
<li>Gif引擎</li>
</ul>
<p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="external">FLAnimatedImage</a>Flipboard开源的Gif引擎</p>
<ul>
<li>缓存</li>
</ul>
<p><a href="https://github.com/REN-LEI/RENCache" target="_blank" rel="external">RENCache</a>简单的缓存解决方案<br><a href="https://github.com/rnapier/RNCachingURLProtocol" target="_blank" rel="external">RNCachingURLProtocol</a>webView离线缓存库<br><a href="https://github.com/Haneke/HanekeSwift" target="_blank" rel="external">HanekeSwift</a>Swift语言书写的轻量级图片缓存框架<br><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCachePath</a>官方开源的图片缓存框架<br><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">Kingfisher</a>猫神用Swift实现图片下载缓存框架  </p>
<ul>
<li>文本相关</li>
</ul>
<p><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a>非常强大的Label，支持属性，数据诊断和链接<br><a href="https://github.com/slackhq/SlackTextViewController" target="_blank" rel="external">SlackTextViewController</a>Slack<br>开源的drop-in UIViewController subclass with a growing text input view and other useful messaging features<br><a href="https://github.com/honcheng/RTLabel" target="_blank" rel="external">RTLabel</a>可以展示Html的Label<br><a href="https://github.com/12207480/TYAttributedLabel" target="_blank" rel="external">TYAttributedLabel</a>强大的属性文本控件(无需了解CoreText<br>)，支持图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示<br><a href="https://github.com/cloverstudio/CSGrowingTextView" target="_blank" rel="external">CSGrowingTextView</a>文本框会随着输入字数改变高度<br><a href="https://github.com/lexrus/LTMorphingLabel" target="_blank" rel="external">LTMorphingLabel</a>效果非常炫的文本框<br><a href="https://github.com/raulriera/TextFieldEffects" target="_blank" rel="external">TextFieldEffects</a>动效非常不错的文本输入框<br><a href="https://github.com/daiweilai/DDRichText" target="_blank" rel="external">DDRichText</a>图文混排<br><a href="https://github.com/AirSars/BMLine" target="_blank" rel="external">BMLine</a>为你的View增加线条<br><a href="https://github.com/devxoul/UITextView-Placeholder" target="_blank" rel="external">UITextView-Placeholder</a>A missing placeholder for UITextView.  </p>
<ul>
<li>加载进度</li>
</ul>
<p><a href="https://github.com/danielamitay/DACircularProgress" target="_blank" rel="external">DACircularProgress</a>各种圆形和圆环型进度指示<br><a href="https://github.com/ninjinkun/NJKWebViewProgress" target="_blank" rel="external">NJKWebViewProgress</a>UIWebView progress interface<br><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">MBProgressHUD</a>这个不用讲，基本上都会用<br><a href="https://github.com/SVProgressHUD/SVProgressHUD" target="_blank" rel="external">SVProgressHUD</a>又一个进度指示<br><a href="https://github.com/scalessec/Toast" target="_blank" rel="external">Toast</a>和MBProgressHUD差不多<br><a href="https://github.com/iTofu/LCProgressHUD" target="_blank" rel="external">LCProgressHUD</a>对MBProgressHUD的简单封装，非常实用<br><a href="https://github.com/KrauseFx/TSMessages/" target="_blank" rel="external">TSMessages</a>消息通知提醒框，非常好用<br><a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="external">PINRemoteImage</a>Pinterest</p>
<ul>
<li>抓取远程图片类</li>
</ul>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>最广泛使用的图片缓存框架<br><a href="https://github.com/Alamofire/AlamofireImage" target="_blank" rel="external">AlamofireImage</a>Swift版本的SDWebImage  </p>
<ul>
<li>键盘类</li>
</ul>
<p><a href="https://github.com/danielamitay/DAKeyboardControl" target="_blank" rel="external">DAKeyboardControl</a>一个键盘管理框架<br><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="external">IQKeyboardManager</a>全局键盘管理<br><a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="external">TPKeyboardAvoiding</a>使用时设置scrollView的类为TPKeyboardAvoidingScrollView<br>即可支持xib<br><a href="https://github.com/datwelk/RDRStickyKeyboardView" target="_blank" rel="external">RDRStickyKeyboardView</a>作者已经停止维护。。。</p>
<ul>
<li>抽屉</li>
</ul>
<p><a href="https://github.com/ViewDeck/ViewDeck" target="_blank" rel="external">ViewDeck</a>功能强大的抽屉效果<br><a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">MMDrawerController</a>又一个抽屉<br><a href="https://github.com/John-Lluch/SWRevealViewController" target="_blank" rel="external">SWRevealViewController</a>A UIViewController subclass for revealing a rear (left and/or right) view controller behind a front controller, inspired by the Facebook app, done right!<br>MSDynamicsDrawerViewControllerContainer view controller that leverages UIKit Dynamics to provide a realistic drawer navigation paradigm.<br><a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="external">PKRevealController</a>安装简便，高度定制且对手势识别良好  </p>
<ul>
<li>NavigationBar  </li>
</ul>
<p><a href="https://github.com/andreamazz/AMScrollingNavbar" target="_blank" rel="external">AMScrollingNavbar</a>Swift</p>
<p>语言编写上下滑动时动态隐藏标题栏</p>
<p><a href="https://github.com/ltebean/LTNavigationbar" target="_blank" rel="external">LTNavigationbar</a>导航栏颜色动态改变<br><a href="https://github.com/JazysYu/JZNavigationExtension" target="_blank" rel="external">JZNavigationExtension</a>Navigation的扩展，推荐</p>
<ul>
<li>ScrollView相关</li>
</ul>
<p><a href="https://github.com/nicklockwood/SwipeView" target="_blank" rel="external">SwipeView</a>SwipeView is a class designed to simplify the implementation of horizontal, paged scrolling views on iOS. It is based on a UIScrollView, but adds convenient functionality such as a UITableView-style dataSource/delegate interface for loading views dynamically, and efficient view loading, unloading and recycling.<br><a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">SWTableViewCell</a>自定义Cell侧滑动作<br><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="external">MGSwipeTableCell</a>自定义Cell侧滑动作，效果多样<br><a href="https://github.com/chiahsien/CHTCollectionViewWaterfallLayout" target="_blank" rel="external">CHTCollectionViewWaterfallLayout</a>瀑布流布局<br><a href="https://github.com/12207480/TYSlidePageScrollView" target="_blank" rel="external">TYSlidePageScrollView</a>An easy solution to page views or controllers with header and page tabbar,footer<br><a href="https://github.com/wangruofeng/XLPagerTabStrip" target="_blank" rel="external">XLPagerTabStrip</a>Android PagerTabStrip for iOS. nice</p>
<ul>
<li>MJ系列</li>
</ul>
<p><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">MJExtension</a>model &lt;–&gt; dic &lt;–&gt; json 框架<br><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a>刷新控件</p>
<ul>
<li>数据库</li>
</ul>
<p><a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">realm-cocoa</a>跨平台轻量级数据库解决方案,励志取代Core Data&amp; SQLite<br><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">fmdb</a>对sqlite实现面向对象的封装</p>
<ul>
<li>图标库</li>
</ul>
<p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a>提供各种图标样式，性能还非常不错<br><a href="https://github.com/danielgindi/Charts" target="_blank" rel="external">Charts</a>Beautiful charts for iOS/tvOS/OSX! The Apple side of the crossplatform MPAndroidChart.  </p>
<ul>
<li>图片处理以及展示相关  </li>
</ul>
<p><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a>开源基于GPU的图片渲染引擎，带有很多款滤镜<br><a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">FXBlurView</a>背景模糊<br><a href="https://github.com/thiagoperes/IDMPhotoBrowser" target="_blank" rel="external">IDMPhotoBrowser</a>照片浏览器<br><a href="https://github.com/arturgrigor/AGImagePickerController" target="_blank" rel="external">AGImagePickerController</a>相册选择<br><a href="https://github.com/AwesomeDennis/DNImagePicker" target="_blank" rel="external">DNImagePicker</a>仿照微信的照片选取器<br><a href="https://github.com/johnil/JFImagePickerController" target="_blank" rel="external">JFImagePickerController</a>又一个照片选取器<br><a href="https://github.com/kean/Nuke" target="_blank" rel="external">Nuke</a>Image loading, processing, caching and preheating</p>
<ul>
<li>日历选择</li>
</ul>
<p><a href="https://github.com/WenchaoD/FSCalendar" target="_blank" rel="external">FSCalendar</a>iOS7+风格的日历控件，非常漂亮</p>
<ul>
<li>音频/视频</li>
</ul>
<p><a href="https://github.com/36Kr-Mobile/KRVideoPlayer" target="_blank" rel="external">KRVideoPlayer</a>36氪开源的视频播放器<br><a href="https://github.com/douban/DOUAudioStreamer" target="_blank" rel="external">DOUAudioStreamer</a>豆瓣开源的音频播放器</p>
<ul>
<li>内购/推广</li>
</ul>
<p><a href="https://github.com/saturngod/IAPHelper" target="_blank" rel="external">IAPHelper</a>in app purchases helper for iOS<br><a href="https://github.com/danielamitay/DAAppsViewController" target="_blank" rel="external">DAAppsViewController</a>应用推广界面，填写合作app的appleId即可<br><a href="https://github.com/JanC/TAPromotee" target="_blank" rel="external">TAPromotee</a>交叉推广应用是你可以免费实现的最佳市场推广策略之一。</p>
<ul>
<li>存储相关</li>
</ul>
<p><a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SSKeychain</a>钥匙串存储<br><a href="https://github.com/wangruofeng/PINCache" target="_blank" rel="external">PINCachePinterest</a>出品的非阻塞式异步缓存工具<br><a href="https://github.com/tumblr/TMCache" target="_blank" rel="external">TMCachetumblr</a>出品的对象快速异步缓存，支持iOS和OS X<br><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">MagicalRecord</a>简化Core Data抓取数据的逻辑，推荐<br><a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" rel="external">KeychainAccess</a>Simple Swift wrapper for Keychain that works on iOS and OS X<br><a href="https://github.com/kishikawakatsumi/UICKeyChainStore" target="_blank" rel="external">UICKeyChainStore</a>UICKeyChainStore的简单封装</p>
<ul>
<li>实用控件</li>
</ul>
<p><a href="https://github.com/hsousa/HCSStarRatingView" target="_blank" rel="external">HCSStarRatingView</a>简单的评分控件<br><a href="https://github.com/LeoNatan/LNNotificationsUI" target="_blank" rel="external">LNNotifications</a>UI模仿iOS标准通知界面，可以以假乱真<br><a href="https://github.com/vikmeup/SCLAlertView-Swift" target="_blank" rel="external">SCLAlertView-Swift</a>非常漂亮的动画Alert View，使用Swift书写<br><a href="https://github.com/dsxNiubility/Wonderful" target="_blank" rel="external">Wonderful</a>跑马灯,彩色标签,渐变等。。。<br><a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="external">VVeboTableViewDemo</a>VVebo剥离的TableView绘制<br><a href="https://github.com/nicklockwood/FXForms" target="_blank" rel="external">FXForms</a>快速创建表单,设置页,用户数据任务,非常棒<br><a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="external">SVPullToRefresh</a>一行代码实现UIScrollView下拉刷新或者无限滚动</p>
<ul>
<li>辅助类</li>
</ul>
<p><a href="https://github.com/mattt/Surge" target="_blank" rel="external">Surge</a>利用Accelerate<br>高性能数学计算框架<br><a href="https://github.com/kconner/KMCGeigerCounter" target="_blank" rel="external">KMCGeigerCounter</a>显示当前动画的帧率<br><a href="https://github.com/xing/XNGMarkdownParser" target="_blank" rel="external">XNGMarkdownParser</a>Markdown解析器，将Markdown格式的字符串解析成NSAttributedString格式的字符串<br><a href="https://github.com/mattt/TransformerKit" target="_blank" rel="external">TransformerKit</a>封装了一些常用的NSValueTransformer类<br><a href="https://github.com/nst/RuntimeBrowser" target="_blank" rel="external">RuntimeBrowser</a>Objective-C Runtime Browser, for Mac OS X and iOS<br><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="external">iOS-Runtime-Headers</a>iOS Objective-C headers as derived from runtime introspection</p>
<p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="external">appledoc</a>Objective-C代码，苹果风格文档生成器<br><a href="https://github.com/kristopherjohnson/Markingbird" target="_blank" rel="external">Markingbird</a>Markdown processor written in Swift (translation of MarkdownSharp)</p>
<ul>
<li>Swift</li>
</ul>
<p><a href="https://github.com/allenwong/30DaysofSwift" target="_blank" rel="external">30DaysofSwift</a>allenwong自学Swift的30个工程<br><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="external">SwiftGuide</a>这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排<br><a href="https://github.com/apple/swift-package-manager" target="_blank" rel="external">swift-package-manager</a>Swift包管理工具<br><a href="https://github.com/Carthage/Carthage" target="_blank" rel="external">CarthageSwift</a>依赖管理工具，类似OC的CocoaPods<br><a href="https://github.com/raywenderlich/swift-style-guide" target="_blank" rel="external">swift-style-guideraywenderlich.com</a>官方Swift编程风格规<br><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>Reactive Programming in Swift</p>
<p>作者：imlifengfeng<br>链接：<a href="http://www.jianshu.com/p/91232c11770e" target="_blank" rel="external">http://www.jianshu.com/p/91232c11770e</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/91232c11770e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开源项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/imlifengfeng/iOSBlogAndTools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOSBlogAndTools&lt;/a&gt;iOS开发优秀博客和软件推荐&lt;br&gt;&lt;a href=&quot;https://github.com/CodeHubApp/CodeHub&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CodeHub&lt;/a&gt;browse and maintain your GitHub repositories on any iOS device!&lt;br&gt;&lt;a href=&quot;https://github.com/dkhamsing/open-source-ios-apps&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Open-Source iOS Apps&lt;/a&gt;开源iOS apps列表  &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://LiJiang.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android mvp模式+rxjava+Retrofit</title>
    <link href="http://LiJiang.com/2017/08/28/Android-mvp%E6%A8%A1%E5%BC%8F-rxjava-Retrofit/"/>
    <id>http://LiJiang.com/2017/08/28/Android-mvp模式-rxjava-Retrofit/</id>
    <published>2017-08-28T08:46:26.000Z</published>
    <updated>2017-09-03T10:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己整理了下Android的开发框架做为积累以方便后面的开发，特记录如下：<br>示例代码下载<a href="https://github.com/RiverLeeSunny/Mvp-RxRetrofit.git" target="_blank" rel="external">demo</a>  </p>
<p>整个框架采用已经应用的很广泛并得到了大家认可的mvp模式，mvp用present代替mvc中的C让V变得更纯粹有着良好的复用性。框架中还应用了rxjava响应式编程框架、butterknife注解框架、Retrofit网络库使得代码优雅而流畅。  </p>
<a id="more"></a>
<h2 id="mvp模式"><a href="#mvp模式" class="headerlink" title="mvp模式"></a>mvp模式</h2><p>相信大家对mvc模式已经并不陌生,mvc(Model-View-Controller)，其中M指的是模型层、V指的是视图层、C指的是控制层，三者的关系如下：<br> <div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-27%2011.46.37.png?raw=true" width="480" height="200" alt="图片名称" align="center"><br></div> </p>
<p>在mvc模式中view层不仅通过Controller和model层打交道而且它还可以直接访问model，从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的，Controller并没有完全分离View和Model</p>
<p>在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是通过定义好的接口进行交互的，从而使得在变更View时候可以保持Presenter的不变，即重用！如图：<br> <div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-27%2011.46.56.png?raw=true" width="480" height="200" alt="图片名称" align="center"><br></div> </p>
<ul>
<li>mvp的优点</li>
</ul>
<ol>
<li>模型与视图完全分离，我们可以修改视图而不影响模型；</li>
<li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；</li>
<li>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；</li>
<li>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。</li>
</ol>
<p>例子：  </p>
<ul>
<li>view层<br>包含两个基类MvpBaseActivity、MvpBaseFragment，如果你的view层由一个Activity多个Fragment组成为了防止Activity和present过于臃肿可以让每个Fragment继承MvpBaseFragment来和presenter绑定，然后view和present交互可以通过接口来定义。代码如下：  </li>
</ul>
<p>MvpBaseActivity：  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpBaseActivity</span> &lt;<span class="title">V</span>,<span class="title">T</span> <span class="keyword">extends</span>     <span class="title">MvpBasePresenter</span>&gt; <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MvpBaseActivity"</span>;
    <span class="comment">//presenter对象</span>
    <span class="keyword">private</span> T mPresenter;

    <span class="keyword">protected</span> ProgressDialog progressDialog;


    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="comment">//创建presenter</span>
        mPresenter = createPresenter();
        <span class="comment">//view与presenter建立关联</span>
        mPresenter.attachView((V)<span class="keyword">this</span>);
        Log.i(TAG, <span class="string">"attachView-mPresenter="</span>+mPresenter);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDestroy();
        Log.i(TAG, <span class="string">"onDestroy()-mPresenter="</span>+mPresenter);
        mPresenter.detachView();
    }

    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span>  T <span class="title">createPresenter</span><span class="params">()</span></span>;
    }
</code></pre>
<p>MvpBaseFragment：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpBaseFragment</span>&lt;<span class="title">V</span>,<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MvpBasePresenter</span>&gt; <span class="keyword">extends</span> <span class="title">Fragment</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MvpBaseFragment"</span>;
    <span class="comment">//presenter对象</span>
    <span class="keyword">private</span> T mPresenter;


    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="comment">//创建presenter</span>
        mPresenter = createPresenter();
        <span class="comment">//view与presenter建立关联</span>
        mPresenter.attachView((V)<span class="keyword">this</span>);
        Log.i(TAG, <span class="string">"attachView-mPresenter="</span>+mPresenter);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDestroy();
        Log.i(TAG, <span class="string">"onDestroy()-mPresenter="</span>+mPresenter);
        mPresenter.detachView();
    }

    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span>  T <span class="title">createPresenter</span><span class="params">()</span></span>;

}
</code></pre>
<p>例子中view层接口</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITopicsView</span> </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">setQuestData</span><span class="params">(String string)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;
}
</code></pre>
<ul>
<li>Presenter层  </li>
</ul>
<p>包含MvpBasePresenter、接口Presenter，见代码：</p>
<p>MvpBasePresenter： </p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpBasePresenter</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Presenter</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="comment">//view接口类型的弱引用</span>
    <span class="keyword">protected</span> Reference&lt;V&gt; mViewRef;
    <span class="comment">//建立关联</span>

    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>{
        mViewRef = <span class="keyword">new</span> WeakReference&lt;V&gt;(view);
    }

    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></span>{
        <span class="keyword">if</span>(mViewRef!=<span class="keyword">null</span>){
            mViewRef.clear();
            mViewRef =<span class="keyword">null</span>;
        }
    }

    <span class="function"><span class="keyword">protected</span> V <span class="title">getView</span><span class="params">()</span></span>{
        <span class="keyword">return</span>  mViewRef.get();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewAttached</span><span class="params">()</span></span>{
        <span class="keyword">return</span>  mViewRef !=<span class="keyword">null</span> &amp;&amp; mViewRef.get() !=<span class="keyword">null</span>;
    }

    <span class="comment">/**
     * 每次调用业务请求的时候都要先调用方法检查是否与View建立连接，没有则抛出异常
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkViewAttached</span><span class="params">()</span> </span>{
        <span class="keyword">if</span> (!isViewAttached()) {
            <span class="keyword">throw</span> <span class="keyword">new</span> top.riversunny.mvp_rxretrofit.mvp.MvpBasePresenter.MvpViewNotAttachedException();
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpViewNotAttachedException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>{
        <span class="function"><span class="keyword">public</span> <span class="title">MvpViewNotAttachedException</span><span class="params">()</span> </span>{
            <span class="keyword">super</span>(<span class="string">"请求数据前请先调用 attachView(View) 方法与View建立连接"</span>);
        }
    }
}
</code></pre>
<p>Presenter:</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="comment">/**
     * Presenter与View建立连接
     *
     * <span class="doctag">@param</span> mvpView 与此Presenter相对应的View
     */</span>
    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V mvpView)</span></span>;

    <span class="comment">/**
     * Presenter与View连接断开
     */</span>
    <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></span>;
}
</code></pre>
<p>rxjava的使用可以阅读<br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">http://gank.io/post/560e15be2dca930e00da1083</a></p>
<p>Retrofit的使用可以阅读<br><a href="http://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="external">http://www.jianshu.com/p/308f3c54abdd</a><br><a href="http://www.jianshu.com/p/94ca8a284ebb" target="_blank" rel="external">http://www.jianshu.com/p/94ca8a284ebb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近自己整理了下Android的开发框架做为积累以方便后面的开发，特记录如下：&lt;br&gt;示例代码下载&lt;a href=&quot;https://github.com/RiverLeeSunny/Mvp-RxRetrofit.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;整个框架采用已经应用的很广泛并得到了大家认可的mvp模式，mvp用present代替mvc中的C让V变得更纯粹有着良好的复用性。框架中还应用了rxjava响应式编程框架、butterknife注解框架、Retrofit网络库使得代码优雅而流畅。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>邓白氏编码申请流程</title>
    <link href="http://LiJiang.com/2017/08/15/%E9%82%93%E7%99%BD%E6%B0%8F%E7%BC%96%E7%A0%81%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://LiJiang.com/2017/08/15/邓白氏编码申请流程/</id>
    <published>2017-08-15T11:06:22.000Z</published>
    <updated>2017-08-15T11:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近申请邓白氏编码用于申请苹果公司开发者账号，整个申请流畅整理了一下供大家参考如下：<br>1.访问<a href="https://idmsa.apple.com/IDMSWebAuth/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2Faccount%2F&amp;rv=1" target="_blank" rel="external">苹果开发者网站</a>如下图：  </p>
 <div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-155.28.18.png?raw=true" width="480" height="300" alt="图片名称" align="center"><br></div> 

<p>如果已经有Apple ID直接登录，没有点Create Apple ID按钮创建。  </p>
<a id="more"></a>
<p>2.Apple ID登录成功后,按如下图操作：</p>
<ul>
<li>第一步</li>
</ul>
<div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/Snip20170815_5.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div>   

<ul>
<li>第二步  <div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/Snip20170815_6.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div>  </li>
<li><p>第三步  </p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/Snip20170815_7.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div>  
</li>
<li><p>第四步  </p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/Snip20170815_8.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div> </li>
<li><p>开始填写申请邓白氏编码信息</p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/1617037-a0d07ae7bf4126b6.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div><br><div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/1617037-ff4ad54e5b0bf03e.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div>  

<p>  填写完信息点击continue 提交    </p>
</li>
</ul>
<p>3.提交信息后华夏邓白氏会给你发邮件，然后你按照邮件的信息回复就可以了。邮件内容如下：<br> <div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/Snip20170815_9.png?raw=true" width="480" height="350" alt="图片名称" align="center"><br></div>  </p>
<p>邮件回复成功后等待1~2天即可收到编码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近申请邓白氏编码用于申请苹果公司开发者账号，整个申请流畅整理了一下供大家参考如下：&lt;br&gt;1.访问&lt;a href=&quot;https://idmsa.apple.com/IDMSWebAuth/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;amp;path=%2Faccount%2F&amp;amp;rv=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果开发者网站&lt;/a&gt;如下图：  &lt;/p&gt;
 &lt;div align=&quot;center&quot;&gt;&lt;br&gt; &lt;img src=&quot;https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-155.28.18.png?raw=true&quot; width=&quot;480&quot; height=&quot;300&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;/div&gt; 

&lt;p&gt;如果已经有Apple ID直接登录，没有点Create Apple ID按钮创建。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://LiJiang.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于Hexo yilia主题域名绑定</title>
    <link href="http://LiJiang.com/2017/08/06/%E5%85%B3%E4%BA%8EHexo-yilia%E4%B8%BB%E9%A2%98%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
    <id>http://LiJiang.com/2017/08/06/关于Hexo-yilia主题域名绑定/</id>
    <published>2017-08-06T09:28:15.000Z</published>
    <updated>2017-08-06T09:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>相信有很多程序员的个人博客都是github page + Hexo搭建的，搭建好后的访问地址大都是yourname.github.io格式的域名比较长而且也不够个性，如果想拥有自己的的域名可以去阿里云的万网申请很便宜。前段时间为自己的博客绑定了域名<a href="http://riversunny.top" target="_blank" rel="external">riversunny.top</a>，过程中遇到了些问题所以记录下过程：</p>
<a id="more"></a>
<ul>
<li><p>购买域名<br>1.首先你需要注册阿里云账号<a href="https://www.aliyun.com" target="_blank" rel="external">阿里云注册</a>  </p>
<p>       </p>
  <div align="center"><br>   <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/gaitubao_com_15019424314092-2.png?raw=true" width="500" height="300" alt="图片名称" align="center"><br>  </div>  

<p>2.登录阿里云<a href="https://wanwang.aliyun.com/domain/?spm=5176.8142029.388261.210.apD2jq" target="_blank" rel="external">购买域名</a> </p>
</li>
<li><p>域名解析<br>购买域名后，我们登录进入阿里云官网的<a href="https://netcn.console.aliyun.com/core/domain/list" target="_blank" rel="external">控制台</a>在域名列表中可以查看自己购买的域名，这时你的域名还不能用需要进行域名解析。点击添加解析按钮，依次输入：CNAME、@、Github博客域名然后保存。但有可能遇到CNAME和MX冲突的问题建议使用<a href="https://www.dnspod.cn/console/dashboard" target="_blank" rel="external">DNSpod</a>的域名解析.</p>
</li>
</ul>
<p>1.首先注册<a href="https://www.dnspod.cn/console/dashboard" target="_blank" rel="external">DNSpod</a>账号然后控制台添加你在万网申请的域名如下图：<br><br>    <div align="center"><br>    <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-06%205.00.34.png?raw=true" width="500" height="150" alt="图片名称" align="center"><br></div><br>2.进入万网的控制台修改你申请的域名的DNS解析如图：<br><br>    <div align="center"><br>    <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-06%205.03.20.png?raw=true" width="500" height="180" alt="图片名称" align="center"><br></div> </p>
<ul>
<li>绑定域名  </li>
</ul>
<p>在Hexo source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：riversunny.top（注意前面不添加<a href="http://）如下图：" target="_blank" rel="external">http://）如下图：</a><br><br>    <div align="center"><br>    <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-08-06%205.19.37.png?raw=true" width="500" height="180" alt="图片名称" align="center"><br></div><br>然后运行hexo g和hexo d命令发布就可以了ok</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;域名绑定&quot;&gt;&lt;a href=&quot;#域名绑定&quot; class=&quot;headerlink&quot; title=&quot;域名绑定&quot;&gt;&lt;/a&gt;域名绑定&lt;/h3&gt;&lt;p&gt;相信有很多程序员的个人博客都是github page + Hexo搭建的，搭建好后的访问地址大都是yourname.github.io格式的域名比较长而且也不够个性，如果想拥有自己的的域名可以去阿里云的万网申请很便宜。前段时间为自己的博客绑定了域名&lt;a href=&quot;http://riversunny.top&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;riversunny.top&lt;/a&gt;，过程中遇到了些问题所以记录下过程：&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="http://LiJiang.com/tags/%E5%85%B6%E5%AE%83/"/>
    
      <category term="Hexo" scheme="http://LiJiang.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Android App性能优化-ListView、Bitmap</title>
    <link href="http://LiJiang.com/2017/08/02/Android-App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-ListView%E3%80%81Bitmap/"/>
    <id>http://LiJiang.com/2017/08/02/Android-App性能优化-ListView、Bitmap/</id>
    <published>2017-08-02T14:05:51.000Z</published>
    <updated>2017-08-02T14:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><ul>
<li>1.使用ViewHolder模式来提高效率<br>ViewHolder模式充分利用了ListView的视图缓存机制，避免每次在调用getView()的时候都去通过findViewById()实例化控件。据测试使用ViewHolder将提高50%以上的效率，所以ViewHolder是提高效率的一个重要方法。使用ViewHolder只需要在自定义Adapter定义一个内部类ViewHolder并将布局中的控件作为成员变量，代码如下：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ImageView icon;</div><div class="line">    <span class="keyword">public</span> TextView text;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<p>接下来只需要通过getView()方法中通过视图缓存机制重用缓存即可，代码如下：  </p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.myapplication;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.view.LayoutInflater;</div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.view.ViewGroup;</div><div class="line"><span class="keyword">import</span> android.widget.BaseAdapter;</div><div class="line"><span class="keyword">import</span> android.widget.ImageView;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatItemListViewAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;ChatItemListViewBean&gt; mData;</div><div class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatItemListViewAdapter</span><span class="params">(Context context,</span></span></div><div class="line">                                   List&lt;ChatItemListViewBean&gt; data) &#123;</div><div class="line">        <span class="keyword">this</span>.mData = data;</div><div class="line">        mInflater = LayoutInflater.from(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mData.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mData.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ChatItemListViewBean bean = mData.get(position);</div><div class="line">        <span class="keyword">return</span> bean.getType();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewTypeCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">        ViewHolder holder;</div><div class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (getItemViewType(position) == <span class="number">0</span>) &#123;</div><div class="line">                holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                convertView = mInflater.inflate(</div><div class="line">                        R.layout.chat_item_itemin, <span class="keyword">null</span>);</div><div class="line">                holder.icon = (ImageView) convertView.findViewById(</div><div class="line">                        R.id.icon_in);</div><div class="line">                holder.text = (TextView) convertView.findViewById(</div><div class="line">                        R.id.text_in);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                convertView = mInflater.inflate(</div><div class="line">                        R.layout.chat_item_itemout, <span class="keyword">null</span>);</div><div class="line">                holder.icon = (ImageView) convertView.findViewById(</div><div class="line">                        R.id.icon_out);</div><div class="line">                holder.text = (TextView) convertView.findViewById(</div><div class="line">                        R.id.text_out);</div><div class="line">            &#125;</div><div class="line">            convertView.setTag(holder);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            holder = (ViewHolder) convertView.getTag();</div><div class="line">        &#125;</div><div class="line">        holder.icon.setImageBitmap(mData.get(position).getIcon());</div><div class="line">        holder.text.setText(mData.get(position).getText());</div><div class="line">        <span class="keyword">return</span> convertView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> ImageView icon;</div><div class="line">        <span class="keyword">public</span> TextView text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<ul>
<li>2.不要在getView()方法中做耗时操作</li>
<li>3.控制异步操作的执行频率</li>
<li>4.通常做到上面三点可以解决大部分卡顿现象，但在某些特殊情况下还是偶尔出现卡顿可以开启硬件加速通过设置android:hardwareAccelerated=”true”即可为Activity开启硬件加速</li>
</ul>
<h3 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h3><p>Bitmap操作不慎，很容易造成OOM(Java.lang.OutofMemoryError - 内存溢出)。图片分辨率越高，消耗的内存越大，当加载高分辨率图片的时候，将会非常占用内存，一旦处理不当就会OOM。在使用ListView, GridView等这些大量加载view的组件时，如果没有合理的处理缓存，大量加载Bitmap的时候，更容易引发OOM，综上Bitmap的优化就显得十分重要。</p>
<ul>
<li>Bitmap的高效加载  </li>
</ul>
<p>Android中使用BitmapFactory加载一个图片，该类提供了四个方法：decodeFile、decodeResource、decodeStream、decodeByteArray，分别用于从文件、资源、输入流以及字节数组中加载出一个Bitmap对象。要做到高效加载可以采用BitmapFactory.Options来加载所需尺寸的图片。通过采样率（BitmapFactoty.Options的inSampleSize参数，当inSampleSize = 1时采样后的图片大小为原始图片大小；当inSampleSize大于1比如为2时那么采样后的图片的宽高为原始图片的1/2，而像素为原始图片的1/4，其占有内存的大小为原始图片的1/4。）即可有效加载图片获取采样率也很简单遵循以下流程：<br>  (1)将BitmapFactory.Options的inJustDecodeBounds参数设为true加载图片。<br>  (2)从BitmapFactory.Options中取出原始宽高信息，它们对应于outWidth和outHeight<br>  (3)根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize<br>  (4)将BitmapFactory.Options的inJustDecodeBounds参数设为false重新加载图片<br>  上面4个流程的代码实现如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="comment">//通过采样率可以有效的加载图片，获取采样率的步骤：</span></div><div class="line">      <span class="comment">/*</span></div><div class="line">      (1) 将BitmapFactory.Options的inJustDecodeBounds = true 并加载图片</div><div class="line">      (2) 从BitmapFactory.Options中取出原始图片的宽高信息，它们对应于outWith和outHeight参数</div><div class="line">      (3) 根据采样率的规则并结合view的所需大小计算出inSimpleSize</div><div class="line">      (4) 将BitmapFactory.Options的inJustDecodeBounds = false 然后从新加载图片</div><div class="line">       */</div><div class="line">      <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">      options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">      BitmapFactory.decodeResource(res,resId,options);</div><div class="line">      <span class="comment">//Calculate sampleSize</span></div><div class="line">      options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</div><div class="line"></div><div class="line">      <span class="comment">//Decode bitmap with sampleSize set</span></div><div class="line">      options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> BitmapFactory.decodeResource(res,resId,options);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Bitmap <span class="title">decodeSampledBitmapFromFileDescriptor</span><span class="params">(FileDescriptor fd,<span class="keyword">int</span> reqWidth,<span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">      options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">      BitmapFactory.decodeFileDescriptor(fd,<span class="keyword">null</span>,options);</div><div class="line">      <span class="comment">//Calculate sampleSize</span></div><div class="line">      options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</div><div class="line"></div><div class="line">      <span class="comment">//Decode bitmap with sampleSize set</span></div><div class="line">      options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> BitmapFactory.decodeFileDescriptor(fd,<span class="keyword">null</span>,options);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options,<span class="keyword">int</span> reqWith,<span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span> (reqWith == <span class="number">0</span> || reqHeight == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//raw width and height of image</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</div><div class="line">      Log.d(TAG,<span class="string">"origin,h = "</span> + height + <span class="string">"w = "</span>+width);</div><div class="line">      <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWith)&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> halfWith = width/<span class="number">2</span>;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height/<span class="number">2</span>;</div><div class="line">          <span class="comment">/*</span></div><div class="line">           Calculate the largest inSampleSize value that is a power of 2 and keeps both height and width larger</div><div class="line">           than the requests height and width</div><div class="line">           */</div><div class="line">          <span class="keyword">while</span> ((halfHeight/inSampleSize) &gt;= reqHeight &amp;&amp; (halfWith/inSampleSize) &gt;= reqWith)&#123;</div><div class="line">              inSampleSize *= <span class="number">2</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      Log.d(TAG,<span class="string">"sampleSize = "</span>+ inSampleSize);</div><div class="line">      <span class="keyword">return</span> inSampleSize;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ListView优化&quot;&gt;&lt;a href=&quot;#ListView优化&quot; class=&quot;headerlink&quot; title=&quot;ListView优化&quot;&gt;&lt;/a&gt;ListView优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.使用ViewHolder模式来提高效率&lt;br&gt;ViewHolder模式充分利用了ListView的视图缓存机制，避免每次在调用getView()的时候都去通过findViewById()实例化控件。据测试使用ViewHolder将提高50%以上的效率，所以ViewHolder是提高效率的一个重要方法。使用ViewHolder只需要在自定义Adapter定义一个内部类ViewHolder并将布局中的控件作为成员变量，代码如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewHolder&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ImageView icon;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; TextView text;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;  
&lt;p&gt;接下来只需要通过getView()方法中通过视图缓存机制重用缓存即可，代码如下：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-App性能优化-布局优化</title>
    <link href="http://LiJiang.com/2017/08/02/Android-App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>http://LiJiang.com/2017/08/02/Android-App性能优化-布局优化/</id>
    <published>2017-08-01T16:02:09.000Z</published>
    <updated>2017-08-02T03:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>inculde 标签的使用将需要重用的布局写在一个单独的xml文件中，再使用include标签复用到其他布局中，如下所示： </li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:background</span>=<span class="string">"#ffffff"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/toolbar"</span> /&gt;</span></div><div class="line">	...</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>  
<a id="more"></a>
<p>上面的代码中@layout/toolbar指定了另外的布局文件，通过这种方式就把toolbar这个布局文件包含进来了避免再重复写一遍。<br>toolbar.xml如下： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:id="@+id/toolbar"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="?attr/actionBarSize"</div><div class="line">    android:background="#fefefe"</div><div class="line">    &lt;TextView</div><div class="line">        android:id="@+id/toolbar_title"</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:layout_gravity="center"</div><div class="line">        android:ellipsize="end"</div><div class="line">        android:singleLine="true"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="@dimen/x40"</div><div class="line">        android:textStyle="bold" /&gt;</div><div class="line">    &lt;!--右侧按钮--&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id="@+id/toolbar_right_menu"</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:layout_gravity="right"</div><div class="line">        android:background="?attr/selectableItemBackground"</div><div class="line">        android:gravity="center_vertical"</div><div class="line">        android:paddingRight="@dimen/x30"</div><div class="line">        android:text="安全退出"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="@dimen/x27"</div><div class="line">        android:visibility="gone" /&gt;</div><div class="line">&lt;/android.support.v7.widget.Toolbar&gt;  </div></pre></td></tr></table></figure>
<ul>
<li>merge 标签的使用<br>用法就是直接使用merge标签标签作为复用布局的根节点<br>user.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"姓名"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"年龄"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div></pre></td></tr></table></figure>  
<p>再使用include标签复用到其他布局中  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/ll_aty_choose_role"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/user"</span>/&gt;</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span> &gt;</span></div></pre></td></tr></table></figure>  
<p>这时，系统会自动忽略merge标签，直接把两个Button替换到include标签的位置。<br>也就是说，include和merge是配合使用的  </p>
<ul>
<li>ViewSub使用<br>ViewSub继承了view，宽高都为0非常轻量级，不需要任何绘制。应用场景各种不常用的布局想进度条、显示错误消息等可以使用ViewStub 标签，示例：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ViewStub</span>  </span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/stub_import"</span>  </div><div class="line">    <span class="attr">android:inflatedId</span>=<span class="string">"@+id/panel_import"</span>  </div><div class="line">    <span class="attr">android:layout</span>=<span class="string">"@layout/progress_overlay"</span>  </div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">    <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span> /&gt; </div></pre></td></tr></table></figure>  
<p>在需要加载SubView布局时可以按照下面两种方式：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);  </div><div class="line">// or  </div><div class="line">View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); </div></pre></td></tr></table></figure>  
<p>当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>布局优化的总体原则遵循以下几点：<br>1.尽量减少布局文件的层级。<br>2.在布局层级相同的情况下优先使用FrameLayout和LinearLayout。<br>3.采用include标签、merge标签和ViewSub，merge和include标签配合使用可以降低减少布局的层级，ViewSub提供按需加载的功能</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;inculde 标签的使用将需要重用的布局写在一个单独的xml文件中，再使用include标签复用到其他布局中，如下所示： &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;RelativeLayout&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;#ffffff&quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;layout&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@layout/toolbar&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;RelativeLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式-单例模式</title>
    <link href="http://LiJiang.com/2017/07/30/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://LiJiang.com/2017/07/30/Android设计模式-单例模式/</id>
    <published>2017-07-30T15:37:13.000Z</published>
    <updated>2017-08-02T03:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式保证类只有唯一一个实例，并提供访问一个全局访问方法，一般单例模式有以下几种模式：  </p>
<ul>
<li>懒汉式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};
    <span class="comment">//加锁在一定程度上保证线程安全</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
        instance = <span class="keyword">new</span> SingletonClass();
    }
    <span class="keyword">return</span> instance;
}
</code></pre>
<p>说明：懒汉式是延迟加载的，只用调用 getInstance()方法时才会创建单例一定程度上节约了系统资源，单线程下懒汉式能够很好的工作，但在多线程下可能创建多个实例，所以不建议使用。  </p>
<a id="more"></a>
<ul>
<li>饿汉式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<p>说明：饿汉式利用static关键字在类加载时就会初始化单例对象，并且缓存到静态内存中。final关键字使其是线程安全的因为JVM会自动对fianl 进行上锁同步。缺点就是类一加载时就会创建实例，所以会较早的占用系统资源。</p>
<ul>
<li>双重锁式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClsaa</span></span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonClass instance = <span class="keyword">null</span>;
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
        <span class="keyword">synchronized</span>(SingletonClass.class){
            <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
            instance = <span class="keyword">new</span> SingletonClass();
            }
        }
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<p>说明：双重锁式很大程度上解决了线程安全的问题同时也实现了延迟加载的问题，但使用了volatile关键字会使JVM对该段代码的优化丧失影响性能，并且在一些高并发的情况下仍可能创建多个实例，这称为双重检查锁定失效。</p>
<ul>
<li>静态内部类  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>{
        <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();
    }

    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">return</span> SingletonHolder.instance;
    }
}
</code></pre>
<p>说明：静态内部类确保了在首次调用getInstance()的时候才会初始化SingletonHolder，从而导致实例被创建，并且由JVM保证了线程的安全。这是比较好的创建单例模式的方法。 </p>
<ul>
<li>枚举式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonClass{
    <span class="comment">//定义一个枚举元素，它就是单例的实例。</span>
    instance;

    <span class="keyword">public</span> <span class="keyword">void</span> doSomething{
    <span class="comment">//do something ...</span>
    }
}
</code></pre>
<p>使用方法如下：  </p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
   Singleton singleton = Singleton.instance;
   singleton.doSomething();
}
</code></pre>
<p>说明：枚举单例模式最大的优点就是写法简单，枚举在java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法，最重要的是默认枚举实例是线程安全的，并且在任何情况下，它都是一个单例。即使是在反序列化的过程，枚举单例也不会重新生成新的实例。而其他几种方式，必须加入如下方法：  </p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span>  <span class="keyword">throws</span> ObjectStreamException</span>{
    <span class="keyword">return</span> INSTANCE;
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="实现单例模式有以下几个关键点："><a href="#实现单例模式有以下几个关键点：" class="headerlink" title="实现单例模式有以下几个关键点："></a>实现单例模式有以下几个关键点：</h3><p>（1）其构造函数不对外开放，一般为private；<br>（2）通过一个静态方法或者枚举返回单例类对象；<br>（3）确保单例类的对象有且只有一个，尤其要注意多线程的场景；<br>（4）确保单例类对象在反序列化时不会重新创建对象；</p>
<p>通过将单例类的构造函数私有化，使得客户端不能通过new的形式手动构造单例类的对象。单例类会主动暴露一个公有的静态方法，客户端调用这个静态的方法获取到单例类的唯一实例。在获取这个单例类的时候需要确保这个过程是线程安全的。<br>不管以哪种形式实现单例模式，它们的核心原理是将构造函数私有化，并且通过静态公有方法获取一个唯一的实例，在这个获取的过程中必须保证线程的安全，同时也要防止反序列化导致重新生成实例对象</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式保证类只有唯一一个实例，并提供访问一个全局访问方法，一般单例模式有以下几种模式：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒汉式  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonClass&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SingletonClass instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{};
    &lt;span class=&quot;comment&quot;&gt;//加锁在一定程度上保证线程安全&lt;/span&gt;
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; SingletonClass &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;){
        instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SingletonClass();
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：懒汉式是延迟加载的，只用调用 getInstance()方法时才会创建单例一定程度上节约了系统资源，单线程下懒汉式能够很好的工作，但在多线程下可能创建多个实例，所以不建议使用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android View事件分发机制</title>
    <link href="http://LiJiang.com/2017/07/29/Android-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://LiJiang.com/2017/07/29/Android-View事件分发机制/</id>
    <published>2017-07-29T14:49:35.000Z</published>
    <updated>2017-08-02T03:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>事件分发机制主要说的是当MotionEvent事件产生后，系统需要把它分发到一个具体的View进行处理，而MotionEvent就是要分发的事件对象这个传递的过程就是分发过程。</p>
<h1 id="MotionEvent事件"><a href="#MotionEvent事件" class="headerlink" title="MotionEvent事件"></a>MotionEvent事件</h1><p>MotionEvent对象描述的是与用户触摸状态相关的时间序列，该序列从用户首次触摸屏幕开始，经历手指在屏幕表面的任何移动，直到手指离开屏幕时结束。手指的初次触摸(ACTION_DOWN操作)，滑动(ACTION_MOVE操作)和抬起(ACTION_UP)都会创建MotionEvent对象   </p>
<a id="more"></a>
<ul>
<li><p>常用的事件  </p>
<p>   事件        | 说明<br>   ——————- |:——————-:<br>   ACTION_DOWN         | 手指 初次接触到屏幕 时触发<br>   ACTION_MOVE             | 手指 在屏幕上滑动 时触发，会多次触发<br>   ACTION_UP               | 手指 离开屏幕 时触发<br>   ACTION_CANCEL        |事件 被上层拦截 时触发<br>   ACTION_OUTSIDE            |手指 不在控件区域 时触发<br>   ACTION_POINTER_DOWN |有非主要的手指按下(即按下之前已经有手指在屏幕上，用于多点触碰)<br>  ACTION_POINTER_UP    |有非主要的手指抬起(即抬起之后仍然有手指在屏幕上，用于多点触碰)  </p>
<p>  一次简单的触摸事件：<br>  手指落下(ACTION_DOWN) －&gt; 多次移动(ACTION_MOVE) －&gt; 离开(ACTION_UP)<br>  ACTION_MOVE 有多次触发，如果仅仅是单击(手指按下再抬起)，不会触发 ACTION_MOVE。针对这样一次触摸事件一般这样处理：  </p>
<pre><code class="java">  <span class="meta">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
  <span class="keyword">switch</span> (event.getAction()){
      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:
          <span class="comment">// 手指按下</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
          <span class="comment">// 手指移动</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_UP:
          <span class="comment">// 手指抬起</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:
          <span class="comment">// 事件被拦截 </span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_OUTSIDE:
          <span class="comment">// 超出区域 </span>
          <span class="keyword">break</span>;
  }
  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);
}
</code></pre>
</li>
</ul>
<h1 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h1><p>Android上的View是树形结构一层一层嵌套叠加在一起的，这种情况下用户点击时就会出现有多个View可以响应，这时就需要事件分发机制，如下图所示：</p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/005Xtdi2jw1f87nsnluf5j308c0eamxg-2.jpg?raw=true = 200x" alt=""><br></div> 

<ul>
<li>View的结构和关系  <div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-2812.25.06.png?raw=true" width="480" height="450" alt="图片名称" align="center"><br></div><br><div align="center"><br>结构图<br></div>     

</li>
</ul>
<div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-28%2011.50.36.png?raw=true" width="300" height="450" alt="图片名称" align="center"><br></div>  

<div align="center"><br>关系图<br></div>  

<h3 id="PhoneWindow-和-DecorView"><a href="#PhoneWindow-和-DecorView" class="headerlink" title="PhoneWindow 和 DecorView"></a>PhoneWindow 和 DecorView</h3><blockquote>
<p>PhoneWindow类继承于Window类，是Window类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个DecorView对象，该DectorView对象是所有应用窗口(Activity界面)的根View。 简而言之，PhoneWindow类是把一个FrameLayout类即DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。<br>DecorView类是PhoneWindow类的内部类。该类是一个FrameLayout的子类，并且是PhoneWindow的子类，该类就是对普通的FrameLayout进行功能的扩展，更确切点可以说是修饰(Decor的英文全称是Decoration，即“修饰”的意思)，比如说添加TitleBar(标题栏)，以及TitleBar上的滚动条等 。最重要的一点是，它是所有应用窗口的根View 。  </p>
</blockquote>
<p>见类图：<br> <div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/108817-20161124172233487-1624168604.jpg?raw=true = 200x" alt=""><br></div>   </p>
<p>###事件分发机制的代码分析<br>事件的分发、拦截、处理分别对应三个方法dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent  </p>
<ul>
<li>事件的分发：dispatchTouchEvent<br>如果事件能够传递给当前的View，那么此方法一定会调用返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。  </li>
<li>事件拦截：onInterceptTouchEvent<br>上述方法用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中此方法不会再调用，返回结果代表是否拦截事件。</li>
<li>事件处理：onTouchEvent<br>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。   </li>
</ul>
<blockquote>
<p>Activity和View只有dispatchTouchEvent、onTouchEvent方法没有onInterceptTouchEvent方法，因为Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果，而View做为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。  </p>
</blockquote>
<ul>
<li><p>事件分发流程<br>事件收集之后最先传递给 Activity， 然后依次向下传递。如果最后分发到View，如果这个View也没有处理事件怎么办，如果没有任何View消费掉事件，那么这个事件会按照反方向回传，最终传回给Activity，如果最后 Activity 也没有处理，本次事件才会被抛弃，如下图：   </p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-2710.33.04.png?raw=true = 200x" alt=""><br></div>  
</li>
<li><p>View的事件分发伪代码如下： </p>
</li>
</ul>
<pre><code class="java"><span class="comment">/** 把事件分发到目标对象，因为这里是View对象，默认不含有child，所以这里他会把事件分发给自己 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>{
    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;
    <span class="comment">//如果有事件监听器，先让监听器处理事件。</span>
    <span class="keyword">if</span> (mOnTouchListener.onTouch(event)) {
        <span class="comment">//如果监听器成功处理了该事件，处理结果设置为true。</span>
        result = <span class="keyword">true</span>;
    }
    <span class="comment">//如果没有监听器，就调用自身的onTouchEvent方法来处理事件。</span>
    <span class="keyword">if</span> (!resutlt &amp;&amp; onTouchEvent(event)) {
        <span class="comment">//如果自身的onTouchEvent成功处理事件，处理结果设置为true。</span>
        result = <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> result;
}
</code></pre>
<ul>
<li>ViewGroup 的事件分发机制伪代码如下:</li>
</ul>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{
    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;             <span class="comment">// 默认状态为没有消费过</span>

    <span class="keyword">if</span> (!onInterceptTouchEvent(ev)) {   <span class="comment">// 如果没有拦截交给子View</span>
        result = child.dispatchTouchEvent(ev);
    }

    <span class="keyword">if</span> (!result) {                      <span class="comment">// 如果事件没有被消费,询问自身onTouchEvent</span>
        result = onTouchEvent(ev);
    }

    <span class="keyword">return</span> result;
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事件分发机制遵循几点原则：  </p>
<ol>
<li>同一个事件系列从手指接触屏幕的那一刻起到手指离开屏幕的那一刻结束。体现在程序上以down事件开始中间含有不定数量的move事件，最终以up事件结束。  </li>
<li>如果事件被消费就意味着事件信息的传递终止。  </li>
<li>如果事件一直没有被消费，最后还会传给Activity，如果Activity也不需要才会被抛弃。  </li>
<li>某个对象一但开始处理事件，那么这一事件序列那么系统都会交由它来处理，如果是GroupView那么onInterceptTouchEvent不会再调用。<br> View的事件分发机制实际上是一个非常经典的责任链模式即当有多个对象可以处理同一个请求时，把这些对象串联成一条链，并沿着这条链传递请求，直到有对象处理它为止。阅读本文可以对事件分发机制有一个整体的了解，更加详细的内容可以研读android事件分发的源码。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;事件分发机制主要说的是当MotionEvent事件产生后，系统需要把它分发到一个具体的View进行处理，而MotionEvent就是要分发的事件对象这个传递的过程就是分发过程。&lt;/p&gt;
&lt;h1 id=&quot;MotionEvent事件&quot;&gt;&lt;a href=&quot;#MotionEvent事件&quot; class=&quot;headerlink&quot; title=&quot;MotionEvent事件&quot;&gt;&lt;/a&gt;MotionEvent事件&lt;/h1&gt;&lt;p&gt;MotionEvent对象描述的是与用户触摸状态相关的时间序列，该序列从用户首次触摸屏幕开始，经历手指在屏幕表面的任何移动，直到手指离开屏幕时结束。手指的初次触摸(ACTION_DOWN操作)，滑动(ACTION_MOVE操作)和抬起(ACTION_UP)都会创建MotionEvent对象   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
</feed>
