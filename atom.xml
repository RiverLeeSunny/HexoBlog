<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>River</title>
  <subtitle>以梦为马，不负韶光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LiJiang.com/"/>
  <updated>2017-08-02T14:19:48.000Z</updated>
  <id>http://LiJiang.com/</id>
  
  <author>
    <name>River</name>
    <email>lijiangsiyu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android App性能优化-ListView、Bitmap</title>
    <link href="http://LiJiang.com/2017/08/02/Android-App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-ListView%E3%80%81Bitmap/"/>
    <id>http://LiJiang.com/2017/08/02/Android-App性能优化-ListView、Bitmap/</id>
    <published>2017-08-02T14:05:51.000Z</published>
    <updated>2017-08-02T14:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><ul>
<li>1.使用ViewHolder模式来提高效率<br>ViewHolder模式充分利用了ListView的视图缓存机制，避免每次在调用getView()的时候都去通过findViewById()实例化控件。据测试使用ViewHolder将提高50%以上的效率，所以ViewHolder是提高效率的一个重要方法。使用ViewHolder只需要在自定义Adapter定义一个内部类ViewHolder并将布局中的控件作为成员变量，代码如下：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ImageView icon;</div><div class="line">    <span class="keyword">public</span> TextView text;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<p>接下来只需要通过getView()方法中通过视图缓存机制重用缓存即可，代码如下：  </p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.myapplication;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.view.LayoutInflater;</div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.view.ViewGroup;</div><div class="line"><span class="keyword">import</span> android.widget.BaseAdapter;</div><div class="line"><span class="keyword">import</span> android.widget.ImageView;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatItemListViewAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;ChatItemListViewBean&gt; mData;</div><div class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatItemListViewAdapter</span><span class="params">(Context context,</span></span></div><div class="line">                                   List&lt;ChatItemListViewBean&gt; data) &#123;</div><div class="line">        <span class="keyword">this</span>.mData = data;</div><div class="line">        mInflater = LayoutInflater.from(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mData.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mData.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ChatItemListViewBean bean = mData.get(position);</div><div class="line">        <span class="keyword">return</span> bean.getType();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewTypeCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">        ViewHolder holder;</div><div class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (getItemViewType(position) == <span class="number">0</span>) &#123;</div><div class="line">                holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                convertView = mInflater.inflate(</div><div class="line">                        R.layout.chat_item_itemin, <span class="keyword">null</span>);</div><div class="line">                holder.icon = (ImageView) convertView.findViewById(</div><div class="line">                        R.id.icon_in);</div><div class="line">                holder.text = (TextView) convertView.findViewById(</div><div class="line">                        R.id.text_in);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                convertView = mInflater.inflate(</div><div class="line">                        R.layout.chat_item_itemout, <span class="keyword">null</span>);</div><div class="line">                holder.icon = (ImageView) convertView.findViewById(</div><div class="line">                        R.id.icon_out);</div><div class="line">                holder.text = (TextView) convertView.findViewById(</div><div class="line">                        R.id.text_out);</div><div class="line">            &#125;</div><div class="line">            convertView.setTag(holder);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            holder = (ViewHolder) convertView.getTag();</div><div class="line">        &#125;</div><div class="line">        holder.icon.setImageBitmap(mData.get(position).getIcon());</div><div class="line">        holder.text.setText(mData.get(position).getText());</div><div class="line">        <span class="keyword">return</span> convertView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> ImageView icon;</div><div class="line">        <span class="keyword">public</span> TextView text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<ul>
<li>2.不要在getView()方法中做耗时操作</li>
<li>3.控制异步操作的执行频率</li>
<li>4.通常做到上面三点可以解决大部分卡顿现象，但在某些特殊情况下还是偶尔出现卡顿可以开启硬件加速通过设置android:hardwareAccelerated=”true”即可为Activity开启硬件加速</li>
</ul>
<h3 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h3><p>Bitmap操作不慎，很容易造成OOM(Java.lang.OutofMemoryError - 内存溢出)。图片分辨率越高，消耗的内存越大，当加载高分辨率图片的时候，将会非常占用内存，一旦处理不当就会OOM。在使用ListView, GridView等这些大量加载view的组件时，如果没有合理的处理缓存，大量加载Bitmap的时候，更容易引发OOM，综上Bitmap的优化就显得十分重要。</p>
<ul>
<li>Bitmap的高效加载  </li>
</ul>
<p>Android中使用BitmapFactory加载一个图片，该类提供了四个方法：decodeFile、decodeResource、decodeStream、decodeByteArray，分别用于从文件、资源、输入流以及字节数组中加载出一个Bitmap对象。要做到高效加载可以采用BitmapFactory.Options来加载所需尺寸的图片。通过采样率（BitmapFactoty.Options的inSampleSize参数，当inSampleSize = 1时采样后的图片大小为原始图片大小；当inSampleSize大于1比如为2时那么采样后的图片的宽高为原始图片的1/2，而像素为原始图片的1/4，其占有内存的大小为原始图片的1/4。）即可有效加载图片获取采样率也很简单遵循以下流程：<br>  (1)将BitmapFactory.Options的inJustDecodeBounds参数设为true加载图片。<br>  (2)从BitmapFactory.Options中取出原始宽高信息，它们对应于outWidth和outHeight<br>  (3)根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize<br>  (4)将BitmapFactory.Options的inJustDecodeBounds参数设为false重新加载图片<br>  上面4个流程的代码实现如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="comment">//通过采样率可以有效的加载图片，获取采样率的步骤：</span></div><div class="line">      <span class="comment">/*</span></div><div class="line">      (1) 将BitmapFactory.Options的inJustDecodeBounds = true 并加载图片</div><div class="line">      (2) 从BitmapFactory.Options中取出原始图片的宽高信息，它们对应于outWith和outHeight参数</div><div class="line">      (3) 根据采样率的规则并结合view的所需大小计算出inSimpleSize</div><div class="line">      (4) 将BitmapFactory.Options的inJustDecodeBounds = false 然后从新加载图片</div><div class="line">       */</div><div class="line">      <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">      options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">      BitmapFactory.decodeResource(res,resId,options);</div><div class="line">      <span class="comment">//Calculate sampleSize</span></div><div class="line">      options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</div><div class="line"></div><div class="line">      <span class="comment">//Decode bitmap with sampleSize set</span></div><div class="line">      options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> BitmapFactory.decodeResource(res,resId,options);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Bitmap <span class="title">decodeSampledBitmapFromFileDescriptor</span><span class="params">(FileDescriptor fd,<span class="keyword">int</span> reqWidth,<span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">      options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">      BitmapFactory.decodeFileDescriptor(fd,<span class="keyword">null</span>,options);</div><div class="line">      <span class="comment">//Calculate sampleSize</span></div><div class="line">      options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</div><div class="line"></div><div class="line">      <span class="comment">//Decode bitmap with sampleSize set</span></div><div class="line">      options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> BitmapFactory.decodeFileDescriptor(fd,<span class="keyword">null</span>,options);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options,<span class="keyword">int</span> reqWith,<span class="keyword">int</span> reqHeight)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span> (reqWith == <span class="number">0</span> || reqHeight == <span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//raw width and height of image</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</div><div class="line">      Log.d(TAG,<span class="string">"origin,h = "</span> + height + <span class="string">"w = "</span>+width);</div><div class="line">      <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWith)&#123;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> halfWith = width/<span class="number">2</span>;</div><div class="line">          <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height/<span class="number">2</span>;</div><div class="line">          <span class="comment">/*</span></div><div class="line">           Calculate the largest inSampleSize value that is a power of 2 and keeps both height and width larger</div><div class="line">           than the requests height and width</div><div class="line">           */</div><div class="line">          <span class="keyword">while</span> ((halfHeight/inSampleSize) &gt;= reqHeight &amp;&amp; (halfWith/inSampleSize) &gt;= reqWith)&#123;</div><div class="line">              inSampleSize *= <span class="number">2</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      Log.d(TAG,<span class="string">"sampleSize = "</span>+ inSampleSize);</div><div class="line">      <span class="keyword">return</span> inSampleSize;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ListView优化&quot;&gt;&lt;a href=&quot;#ListView优化&quot; class=&quot;headerlink&quot; title=&quot;ListView优化&quot;&gt;&lt;/a&gt;ListView优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.使用ViewHolder模式来提高效率&lt;br&gt;ViewHolder模式充分利用了ListView的视图缓存机制，避免每次在调用getView()的时候都去通过findViewById()实例化控件。据测试使用ViewHolder将提高50%以上的效率，所以ViewHolder是提高效率的一个重要方法。使用ViewHolder只需要在自定义Adapter定义一个内部类ViewHolder并将布局中的控件作为成员变量，代码如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewHolder&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ImageView icon;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; TextView text;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;  
&lt;p&gt;接下来只需要通过getView()方法中通过视图缓存机制重用缓存即可，代码如下：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-App性能优化-布局优化</title>
    <link href="http://LiJiang.com/2017/08/02/Android-App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>http://LiJiang.com/2017/08/02/Android-App性能优化-布局优化/</id>
    <published>2017-08-01T16:02:09.000Z</published>
    <updated>2017-08-02T03:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>inculde 标签的使用将需要重用的布局写在一个单独的xml文件中，再使用include标签复用到其他布局中，如下所示： </li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:background</span>=<span class="string">"#ffffff"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/toolbar"</span> /&gt;</span></div><div class="line">	...</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>  
<a id="more"></a>
<p>上面的代码中@layout/toolbar指定了另外的布局文件，通过这种方式就把toolbar这个布局文件包含进来了避免再重复写一遍。<br>toolbar.xml如下： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:id="@+id/toolbar"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="?attr/actionBarSize"</div><div class="line">    android:background="#fefefe"</div><div class="line">    &lt;TextView</div><div class="line">        android:id="@+id/toolbar_title"</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:layout_gravity="center"</div><div class="line">        android:ellipsize="end"</div><div class="line">        android:singleLine="true"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="@dimen/x40"</div><div class="line">        android:textStyle="bold" /&gt;</div><div class="line">    &lt;!--右侧按钮--&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id="@+id/toolbar_right_menu"</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="match_parent"</div><div class="line">        android:layout_gravity="right"</div><div class="line">        android:background="?attr/selectableItemBackground"</div><div class="line">        android:gravity="center_vertical"</div><div class="line">        android:paddingRight="@dimen/x30"</div><div class="line">        android:text="安全退出"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="@dimen/x27"</div><div class="line">        android:visibility="gone" /&gt;</div><div class="line">&lt;/android.support.v7.widget.Toolbar&gt;  </div></pre></td></tr></table></figure>
<ul>
<li>merge 标签的使用<br>用法就是直接使用merge标签标签作为复用布局的根节点<br>user.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"姓名"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"年龄"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div></pre></td></tr></table></figure>  
<p>再使用include标签复用到其他布局中  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/ll_aty_choose_role"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/user"</span>/&gt;</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span> &gt;</span></div></pre></td></tr></table></figure>  
<p>这时，系统会自动忽略merge标签，直接把两个Button替换到include标签的位置。<br>也就是说，include和merge是配合使用的  </p>
<ul>
<li>ViewSub使用<br>ViewSub继承了view，宽高都为0非常轻量级，不需要任何绘制。应用场景各种不常用的布局想进度条、显示错误消息等可以使用ViewStub 标签，示例：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ViewStub</span>  </span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/stub_import"</span>  </div><div class="line">    <span class="attr">android:inflatedId</span>=<span class="string">"@+id/panel_import"</span>  </div><div class="line">    <span class="attr">android:layout</span>=<span class="string">"@layout/progress_overlay"</span>  </div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">    <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span> /&gt; </div></pre></td></tr></table></figure>  
<p>在需要加载SubView布局时可以按照下面两种方式：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);  </div><div class="line">// or  </div><div class="line">View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); </div></pre></td></tr></table></figure>  
<p>当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>布局优化的总体原则遵循以下几点：<br>1.尽量减少布局文件的层级。<br>2.在布局层级相同的情况下优先使用FrameLayout和LinearLayout。<br>3.采用include标签、merge标签和ViewSub，merge和include标签配合使用可以降低减少布局的层级，ViewSub提供按需加载的功能</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;inculde 标签的使用将需要重用的布局写在一个单独的xml文件中，再使用include标签复用到其他布局中，如下所示： &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;RelativeLayout&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:layout_width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:layout_height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;android:background&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;#ffffff&quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;layout&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@layout/toolbar&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;RelativeLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式-单例模式</title>
    <link href="http://LiJiang.com/2017/07/30/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://LiJiang.com/2017/07/30/Android设计模式-单例模式/</id>
    <published>2017-07-30T15:37:13.000Z</published>
    <updated>2017-08-02T03:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式保证类只有唯一一个实例，并提供访问一个全局访问方法，一般单例模式有以下几种模式：  </p>
<ul>
<li>懒汉式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};
    <span class="comment">//加锁在一定程度上保证线程安全</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
    <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
        instance = <span class="keyword">new</span> SingletonClass();
    }
    <span class="keyword">return</span> instance;
}
</code></pre>
<p>说明：懒汉式是延迟加载的，只用调用 getInstance()方法时才会创建单例一定程度上节约了系统资源，单线程下懒汉式能够很好的工作，但在多线程下可能创建多个实例，所以不建议使用。  </p>
<a id="more"></a>
<ul>
<li>饿汉式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<p>说明：饿汉式利用static关键字在类加载时就会初始化单例对象，并且缓存到静态内存中。final关键字使其是线程安全的因为JVM会自动对fianl 进行上锁同步。缺点就是类一加载时就会创建实例，所以会较早的占用系统资源。</p>
<ul>
<li>双重锁式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClsaa</span></span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonClass instance = <span class="keyword">null</span>;
    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
        <span class="keyword">synchronized</span>(SingletonClass.class){
            <span class="keyword">if</span>(instance == <span class="keyword">null</span>){
            instance = <span class="keyword">new</span> SingletonClass();
            }
        }
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<p>说明：双重锁式很大程度上解决了线程安全的问题同时也实现了延迟加载的问题，但使用了volatile关键字会使JVM对该段代码的优化丧失影响性能，并且在一些高并发的情况下仍可能创建多个实例，这称为双重检查锁定失效。</p>
<ul>
<li>静态内部类  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>{
        <span class="keyword">public</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();
    }

    <span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>{};

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>{
        <span class="keyword">return</span> SingletonHolder.instance;
    }
}
</code></pre>
<p>说明：静态内部类确保了在首次调用getInstance()的时候才会初始化SingletonHolder，从而导致实例被创建，并且由JVM保证了线程的安全。这是比较好的创建单例模式的方法。 </p>
<ul>
<li>枚举式  </li>
</ul>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonClass{
    <span class="comment">//定义一个枚举元素，它就是单例的实例。</span>
    instance;

    <span class="keyword">public</span> <span class="keyword">void</span> doSomething{
    <span class="comment">//do something ...</span>
    }
}
</code></pre>
<p>使用方法如下：  </p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
   Singleton singleton = Singleton.instance;
   singleton.doSomething();
}
</code></pre>
<p>说明：枚举单例模式最大的优点就是写法简单，枚举在java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法，最重要的是默认枚举实例是线程安全的，并且在任何情况下，它都是一个单例。即使是在反序列化的过程，枚举单例也不会重新生成新的实例。而其他几种方式，必须加入如下方法：  </p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span>  <span class="keyword">throws</span> ObjectStreamException</span>{
    <span class="keyword">return</span> INSTANCE;
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="实现单例模式有以下几个关键点："><a href="#实现单例模式有以下几个关键点：" class="headerlink" title="实现单例模式有以下几个关键点："></a>实现单例模式有以下几个关键点：</h3><p>（1）其构造函数不对外开放，一般为private；<br>（2）通过一个静态方法或者枚举返回单例类对象；<br>（3）确保单例类的对象有且只有一个，尤其要注意多线程的场景；<br>（4）确保单例类对象在反序列化时不会重新创建对象；</p>
<p>通过将单例类的构造函数私有化，使得客户端不能通过new的形式手动构造单例类的对象。单例类会主动暴露一个公有的静态方法，客户端调用这个静态的方法获取到单例类的唯一实例。在获取这个单例类的时候需要确保这个过程是线程安全的。<br>不管以哪种形式实现单例模式，它们的核心原理是将构造函数私有化，并且通过静态公有方法获取一个唯一的实例，在这个获取的过程中必须保证线程的安全，同时也要防止反序列化导致重新生成实例对象</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式保证类只有唯一一个实例，并提供访问一个全局访问方法，一般单例模式有以下几种模式：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;懒汉式  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonClass&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SingletonClass instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{};
    &lt;span class=&quot;comment&quot;&gt;//加锁在一定程度上保证线程安全&lt;/span&gt;
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; SingletonClass &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;){
        instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SingletonClass();
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：懒汉式是延迟加载的，只用调用 getInstance()方法时才会创建单例一定程度上节约了系统资源，单线程下懒汉式能够很好的工作，但在多线程下可能创建多个实例，所以不建议使用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android View事件分发机制</title>
    <link href="http://LiJiang.com/2017/07/29/Android-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://LiJiang.com/2017/07/29/Android-View事件分发机制/</id>
    <published>2017-07-29T14:49:35.000Z</published>
    <updated>2017-08-02T03:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>事件分发机制主要说的是当MotionEvent事件产生后，系统需要把它分发到一个具体的View进行处理，而MotionEvent就是要分发的事件对象这个传递的过程就是分发过程。</p>
<h1 id="MotionEvent事件"><a href="#MotionEvent事件" class="headerlink" title="MotionEvent事件"></a>MotionEvent事件</h1><p>MotionEvent对象描述的是与用户触摸状态相关的时间序列，该序列从用户首次触摸屏幕开始，经历手指在屏幕表面的任何移动，直到手指离开屏幕时结束。手指的初次触摸(ACTION_DOWN操作)，滑动(ACTION_MOVE操作)和抬起(ACTION_UP)都会创建MotionEvent对象   </p>
<a id="more"></a>
<ul>
<li><p>常用的事件  </p>
<p>   事件        | 说明<br>   ——————- |:——————-:<br>   ACTION_DOWN         | 手指 初次接触到屏幕 时触发<br>   ACTION_MOVE             | 手指 在屏幕上滑动 时触发，会多次触发<br>   ACTION_UP               | 手指 离开屏幕 时触发<br>   ACTION_CANCEL        |事件 被上层拦截 时触发<br>   ACTION_OUTSIDE            |手指 不在控件区域 时触发<br>   ACTION_POINTER_DOWN |有非主要的手指按下(即按下之前已经有手指在屏幕上，用于多点触碰)<br>  ACTION_POINTER_UP    |有非主要的手指抬起(即抬起之后仍然有手指在屏幕上，用于多点触碰)  </p>
<p>  一次简单的触摸事件：<br>  手指落下(ACTION_DOWN) －&gt; 多次移动(ACTION_MOVE) －&gt; 离开(ACTION_UP)<br>  ACTION_MOVE 有多次触发，如果仅仅是单击(手指按下再抬起)，不会触发 ACTION_MOVE。针对这样一次触摸事件一般这样处理：  </p>
<pre><code class="java">  <span class="meta">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
  <span class="keyword">switch</span> (event.getAction()){
      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:
          <span class="comment">// 手指按下</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
          <span class="comment">// 手指移动</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_UP:
          <span class="comment">// 手指抬起</span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:
          <span class="comment">// 事件被拦截 </span>
          <span class="keyword">break</span>;
      <span class="keyword">case</span> MotionEvent.ACTION_OUTSIDE:
          <span class="comment">// 超出区域 </span>
          <span class="keyword">break</span>;
  }
  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);
}
</code></pre>
</li>
</ul>
<h1 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h1><p>Android上的View是树形结构一层一层嵌套叠加在一起的，这种情况下用户点击时就会出现有多个View可以响应，这时就需要事件分发机制，如下图所示：</p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/005Xtdi2jw1f87nsnluf5j308c0eamxg-2.jpg?raw=true = 200x" alt=""><br></div> 

<ul>
<li>View的结构和关系  <div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-2812.25.06.png?raw=true" width="480" height="450" alt="图片名称" align="center"><br></div><br><div align="center"><br>结构图<br></div>     

</li>
</ul>
<div align="center"><br> <img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-28%2011.50.36.png?raw=true" width="300" height="450" alt="图片名称" align="center"><br></div>  

<div align="center"><br>关系图<br></div>  

<h3 id="PhoneWindow-和-DecorView"><a href="#PhoneWindow-和-DecorView" class="headerlink" title="PhoneWindow 和 DecorView"></a>PhoneWindow 和 DecorView</h3><blockquote>
<p>PhoneWindow类继承于Window类，是Window类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个DecorView对象，该DectorView对象是所有应用窗口(Activity界面)的根View。 简而言之，PhoneWindow类是把一个FrameLayout类即DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。<br>DecorView类是PhoneWindow类的内部类。该类是一个FrameLayout的子类，并且是PhoneWindow的子类，该类就是对普通的FrameLayout进行功能的扩展，更确切点可以说是修饰(Decor的英文全称是Decoration，即“修饰”的意思)，比如说添加TitleBar(标题栏)，以及TitleBar上的滚动条等 。最重要的一点是，它是所有应用窗口的根View 。  </p>
</blockquote>
<p>见类图：<br> <div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/108817-20161124172233487-1624168604.jpg?raw=true = 200x" alt=""><br></div>   </p>
<p>###事件分发机制的代码分析<br>事件的分发、拦截、处理分别对应三个方法dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent  </p>
<ul>
<li>事件的分发：dispatchTouchEvent<br>如果事件能够传递给当前的View，那么此方法一定会调用返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。  </li>
<li>事件拦截：onInterceptTouchEvent<br>上述方法用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中此方法不会再调用，返回结果代表是否拦截事件。</li>
<li>事件处理：onTouchEvent<br>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。   </li>
</ul>
<blockquote>
<p>Activity和View只有dispatchTouchEvent、onTouchEvent方法没有onInterceptTouchEvent方法，因为Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果，而View做为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。  </p>
</blockquote>
<ul>
<li><p>事件分发流程<br>事件收集之后最先传递给 Activity， 然后依次向下传递。如果最后分发到View，如果这个View也没有处理事件怎么办，如果没有任何View消费掉事件，那么这个事件会按照反方向回传，最终传回给Activity，如果最后 Activity 也没有处理，本次事件才会被抛弃，如下图：   </p>
<div align="center"><br><img src="https://github.com/RiverLeeSunny/markdownPic/blob/master/image_folder/2017-07-2710.33.04.png?raw=true = 200x" alt=""><br></div>  
</li>
<li><p>View的事件分发伪代码如下： </p>
</li>
</ul>
<pre><code class="java"><span class="comment">/** 把事件分发到目标对象，因为这里是View对象，默认不含有child，所以这里他会把事件分发给自己 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>{
    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;
    <span class="comment">//如果有事件监听器，先让监听器处理事件。</span>
    <span class="keyword">if</span> (mOnTouchListener.onTouch(event)) {
        <span class="comment">//如果监听器成功处理了该事件，处理结果设置为true。</span>
        result = <span class="keyword">true</span>;
    }
    <span class="comment">//如果没有监听器，就调用自身的onTouchEvent方法来处理事件。</span>
    <span class="keyword">if</span> (!resutlt &amp;&amp; onTouchEvent(event)) {
        <span class="comment">//如果自身的onTouchEvent成功处理事件，处理结果设置为true。</span>
        result = <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> result;
}
</code></pre>
<ul>
<li>ViewGroup 的事件分发机制伪代码如下:</li>
</ul>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{
    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;             <span class="comment">// 默认状态为没有消费过</span>

    <span class="keyword">if</span> (!onInterceptTouchEvent(ev)) {   <span class="comment">// 如果没有拦截交给子View</span>
        result = child.dispatchTouchEvent(ev);
    }

    <span class="keyword">if</span> (!result) {                      <span class="comment">// 如果事件没有被消费,询问自身onTouchEvent</span>
        result = onTouchEvent(ev);
    }

    <span class="keyword">return</span> result;
}
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事件分发机制遵循几点原则：  </p>
<ol>
<li>同一个事件系列从手指接触屏幕的那一刻起到手指离开屏幕的那一刻结束。体现在程序上以down事件开始中间含有不定数量的move事件，最终以up事件结束。  </li>
<li>如果事件被消费就意味着事件信息的传递终止。  </li>
<li>如果事件一直没有被消费，最后还会传给Activity，如果Activity也不需要才会被抛弃。  </li>
<li>某个对象一但开始处理事件，那么这一事件序列那么系统都会交由它来处理，如果是GroupView那么onInterceptTouchEvent不会再调用。<br> View的事件分发机制实际上是一个非常经典的责任链模式即当有多个对象可以处理同一个请求时，把这些对象串联成一条链，并沿着这条链传递请求，直到有对象处理它为止。阅读本文可以对事件分发机制有一个整体的了解，更加详细的内容可以研读android事件分发的源码。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;事件分发机制主要说的是当MotionEvent事件产生后，系统需要把它分发到一个具体的View进行处理，而MotionEvent就是要分发的事件对象这个传递的过程就是分发过程。&lt;/p&gt;
&lt;h1 id=&quot;MotionEvent事件&quot;&gt;&lt;a href=&quot;#MotionEvent事件&quot; class=&quot;headerlink&quot; title=&quot;MotionEvent事件&quot;&gt;&lt;/a&gt;MotionEvent事件&lt;/h1&gt;&lt;p&gt;MotionEvent对象描述的是与用户触摸状态相关的时间序列，该序列从用户首次触摸屏幕开始，经历手指在屏幕表面的任何移动，直到手指离开屏幕时结束。手指的初次触摸(ACTION_DOWN操作)，滑动(ACTION_MOVE操作)和抬起(ACTION_UP)都会创建MotionEvent对象   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://LiJiang.com/tags/Android/"/>
    
  </entry>
  
</feed>
