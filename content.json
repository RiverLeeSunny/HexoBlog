{"meta":{"title":"LiJiang’s blog","subtitle":"Walk steps step by step","description":"Walk steps step by step","author":"LiJiang","url":"http://LiJiang.com"},"pages":[{"title":"categories","date":"2017-07-19T14:56:50.000Z","updated":"2017-07-19T14:56:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://LiJiang.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-19T14:49:52.000Z","updated":"2017-07-19T14:49:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://LiJiang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android设计模式-单例模式","slug":"Android设计模式-单例模式","date":"2017-07-30T15:37:13.000Z","updated":"2017-07-30T15:39:07.000Z","comments":true,"path":"2017/07/30/Android设计模式-单例模式/","link":"","permalink":"http://LiJiang.com/2017/07/30/Android设计模式-单例模式/","excerpt":"","text":"单例模式保证类只有唯一一个实例，并提供访问一个全局访问方法，一般单例模式有以下几种模式： 懒汉式 public class SingletonClass{ private static SingletonClass instance = null; private SingletonClass(){}; //加锁在一定程度上保证线程安全 public synchronized SingletonClass getInstance(){ if(instance == null){ instance = new SingletonClass(); } return instance; } 说明：懒汉式是延迟加载的，只用调用 getInstance()方法时才会创建单例一定程度上节约了系统资源，单线程下懒汉式能够很好的工作，但在多线程下可能创建多个实例，所以不建议使用。 饿汉式 public class SingletonClass{ private static final SingletonClass instance = new SingletonClass(); private SingletonClass(){ } public static SingletonClass getInstance(){ return instance; } } 说明：饿汉式利用static关键字在类加载时就会初始化单例对象，并且缓存到静态内存中。final关键字使其是线程安全的因为JVM会自动对fianl 进行上锁同步。缺点就是类一加载时就会创建实例，所以会较早的占用系统资源。 双重锁式 public class SingletonClsaa{ public static volatile SingletonClass instance = null; private SingletonClass(){}; public static SingletonClass getInstance(){ if(instance == null){ synchronized(SingletonClass.class){ if(instance == null){ instance = new SingletonClass(); } } return instance; } } 说明：双重锁式很大程度上解决了线程安全的问题同时也实现了延迟加载的问题，但使用了volatile关键字会使JVM对该段代码的优化丧失影响性能，并且在一些高并发的情况下仍可能创建多个实例，这称为双重检查锁定失效。 静态内部类 public class SingletonClass{ private static class SingletonHolder{ public static SingletonClass instance = new SingletonClass(); } private SingletonClass(){}; public static SingletonClass getInstance(){ return SingletonHolder.instance; } } 说明：静态内部类确保了在首次调用getInstance()的时候才会初始化SingletonHolder，从而导致实例被创建，并且由JVM保证了线程的安全。这是比较好的创建单例模式的方法。 枚举式 public enum SingletonClass{ //定义一个枚举元素，它就是单例的实例。 instance; public void doSomething{ //do something ... } } 使用方法如下： public static void main(String[] args){ Singleton singleton = Singleton.instance; singleton.doSomething(); } 说明：枚举单例模式最大的优点就是写法简单，枚举在java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法，最重要的是默认枚举实例是线程安全的，并且在任何情况下，它都是一个单例。即使是在反序列化的过程，枚举单例也不会重新生成新的实例。而其他几种方式，必须加入如下方法： private Object readResolve() throws ObjectStreamException{ return INSTANCE; } 总结实现单例模式有以下几个关键点：（1）其构造函数不对外开放，一般为private；（2）通过一个静态方法或者枚举返回单例类对象；（3）确保单例类的对象有且只有一个，尤其要注意多线程的场景；（4）确保单例类对象在反序列化时不会重新创建对象； 通过将单例类的构造函数私有化，使得客户端不能通过new的形式手动构造单例类的对象。单例类会主动暴露一个公有的静态方法，客户端调用这个静态的方法获取到单例类的唯一实例。在获取这个单例类的时候需要确保这个过程是线程安全的。不管以哪种形式实现单例模式，它们的核心原理是将构造函数私有化，并且通过静态公有方法获取一个唯一的实例，在这个获取的过程中必须保证线程的安全，同时也要防止反序列化导致重新生成实例对象","categories":[],"tags":[]},{"title":"Android View事件分发机制","slug":"Android-View事件分发机制","date":"2017-07-29T14:49:35.000Z","updated":"2017-07-29T15:57:44.000Z","comments":true,"path":"2017/07/29/Android-View事件分发机制/","link":"","permalink":"http://LiJiang.com/2017/07/29/Android-View事件分发机制/","excerpt":"","text":"概述事件分发机制主要说的是当MotionEvent事件产生后，系统需要把它分发到一个具体的View进行处理，而MotionEvent就是要分发的事件对象这个传递的过程就是分发过程。 MotionEvent事件MotionEvent对象描述的是与用户触摸状态相关的时间序列，该序列从用户首次触摸屏幕开始，经历手指在屏幕表面的任何移动，直到手指离开屏幕时结束。手指的初次触摸(ACTION_DOWN操作)，滑动(ACTION_MOVE操作)和抬起(ACTION_UP)都会创建MotionEvent对象 常用的事件 事件 | 说明 ——————- |:——————-: ACTION_DOWN | 手指 初次接触到屏幕 时触发 ACTION_MOVE | 手指 在屏幕上滑动 时触发，会多次触发 ACTION_UP | 手指 离开屏幕 时触发 ACTION_CANCEL |事件 被上层拦截 时触发 ACTION_OUTSIDE |手指 不在控件区域 时触发 ACTION_POINTER_DOWN |有非主要的手指按下(即按下之前已经有手指在屏幕上，用于多点触碰) ACTION_POINTER_UP |有非主要的手指抬起(即抬起之后仍然有手指在屏幕上，用于多点触碰) 一次简单的触摸事件： 手指落下(ACTION_DOWN) －&gt; 多次移动(ACTION_MOVE) －&gt; 离开(ACTION_UP) ACTION_MOVE 有多次触发，如果仅仅是单击(手指按下再抬起)，不会触发 ACTION_MOVE。针对这样一次触摸事件一般这样处理： @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: // 手指按下 break; case MotionEvent.ACTION_MOVE: // 手指移动 break; case MotionEvent.ACTION_UP: // 手指抬起 break; case MotionEvent.ACTION_CANCEL: // 事件被拦截 break; case MotionEvent.ACTION_OUTSIDE: // 超出区域 break; } return super.onTouchEvent(event); } 事件分发过程Android上的View是树形结构一层一层嵌套叠加在一起的，这种情况下用户点击时就会出现有多个View可以响应，这时就需要事件分发机制，如下图所示： = View的结构和关系 结构图 关系图 PhoneWindow 和 DecorView PhoneWindow类继承于Window类，是Window类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个DecorView对象，该DectorView对象是所有应用窗口(Activity界面)的根View。 简而言之，PhoneWindow类是把一个FrameLayout类即DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。DecorView类是PhoneWindow类的内部类。该类是一个FrameLayout的子类，并且是PhoneWindow的子类，该类就是对普通的FrameLayout进行功能的扩展，更确切点可以说是修饰(Decor的英文全称是Decoration，即“修饰”的意思)，比如说添加TitleBar(标题栏)，以及TitleBar上的滚动条等 。最重要的一点是，它是所有应用窗口的根View 。 见类图： = ###事件分发机制的代码分析事件的分发、拦截、处理分别对应三个方法dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 事件的分发：dispatchTouchEvent如果事件能够传递给当前的View，那么此方法一定会调用返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 事件拦截：onInterceptTouchEvent上述方法用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中此方法不会再调用，返回结果代表是否拦截事件。 事件处理：onTouchEvent在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 Activity和View只有dispatchTouchEvent、onTouchEvent方法没有onInterceptTouchEvent方法，因为Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果，而View做为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。 事件分发流程事件收集之后最先传递给 Activity， 然后依次向下传递。如果最后分发到View，如果这个View也没有处理事件怎么办，如果没有任何View消费掉事件，那么这个事件会按照反方向回传，最终传回给Activity，如果最后 Activity 也没有处理，本次事件才会被抛弃，如下图： = View的事件分发伪代码如下： /** 把事件分发到目标对象，因为这里是View对象，默认不含有child，所以这里他会把事件分发给自己 */ public boolean dispatchTouchEvent(MotionEvent event){ boolean result = false; //如果有事件监听器，先让监听器处理事件。 if (mOnTouchListener.onTouch(event)) { //如果监听器成功处理了该事件，处理结果设置为true。 result = true; } //如果没有监听器，就调用自身的onTouchEvent方法来处理事件。 if (!resutlt &amp;&amp; onTouchEvent(event)) { //如果自身的onTouchEvent成功处理事件，处理结果设置为true。 result = true; } return result; } ViewGroup 的事件分发机制伪代码如下: public boolean dispatchTouchEvent(MotionEvent ev) { boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) { // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); } if (!result) { // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); } return result; } 总结事件分发机制遵循几点原则： 同一个事件系列从手指接触屏幕的那一刻起到手指离开屏幕的那一刻结束。体现在程序上以down事件开始中间含有不定数量的move事件，最终以up事件结束。 如果事件被消费就意味着事件信息的传递终止。 如果事件一直没有被消费，最后还会传给Activity，如果Activity也不需要才会被抛弃。 某个对象一但开始处理事件，那么这一事件序列那么系统都会交由它来处理，如果是GroupView那么onInterceptTouchEvent不会再调用。 View的事件分发机制实际上是一个非常经典的责任链模式即当有多个对象可以处理同一个请求时，把这些对象串联成一条链，并沿着这条链传递请求，直到有对象处理它为止。阅读本文可以对事件分发机制有一个整体的了解，更加详细的内容可以研读android事件分发的源码。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-07-18T07:10:26.000Z","updated":"2017-07-18T07:10:26.000Z","comments":true,"path":"2017/07/18/hello-world/","link":"","permalink":"http://LiJiang.com/2017/07/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}